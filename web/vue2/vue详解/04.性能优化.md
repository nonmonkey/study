[TOC]

---

打包体积优化

运行时优化

#### 一、使用key

对于通过循环生成列表、应该给每个列表项一个稳定且唯一的key，这有利于在列表变动时，尽量少的删除、新增、改动元素。

#### 二、使用冻结的对象

冻结的对象```Object.freeze```不会被响应化。

#### 三、使用函数式组件

https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6

没有componentInstance属性，即组件实例。
运行时间上差不多，内存占用比较少。

```JS
Vue.component('my-component', {
  functional: true,
  // Props 是可选的
  props: {
    // ...
  },
  // 为了弥补缺少的实例
  // 提供第二个参数作为上下文
  render: function (createElement, context) {
    // ...
  }
})
```
或者
```HTML
<template functional>
</template>
```

#### 四、使用计算属性

如果模板中某个数据会使用多次，并且该数据是通过计算得到的，使用计算属性以缓存他们。

#### 五、非实时绑定的表单项

当使用v-model绑定一个表单项时，当用户改变表单项的状态时，也会随之改变数据，从而导致vue发生重渲染（rerender），这会带来一些性能的开销。

特别是当用户改变表单项时，页面有一些动画在进行中，由于js执行线程和浏览器渲染线程是互斥的，最终会导致动画出现卡顿。

我们可以通过使用lazy或不适用v-model的方式来解决问题，但要注意，这样可能会导致在某一个时间段内数据和表单项的值是不一致的。

#### 六、保持对象引用稳定

在绝大多数情况下，vue触发rerender的时机是其依赖的数据发生变化

若数据没有发生变化，哪怕给数据重新赋值了，vue也是不会做出任何处理的。

下面是vue判断数据没有变化的源码：
```JS
// value 为旧值，newVal为新值
if (newVal === value || (newVal !== newVal && value !== value)) {
  return
}
```

因此，如果需要，只要能保证组件的依赖数据不发生变化，组件就不会重新渲染。

对于原始数据类型，保持其值不变即可

对于对象类型，保持其值不变即可。

从另一方面来说，由于可以通过保持属性引用稳定来避免子组件的重渲染，那么我们应该细分组件来尽量避免多余的渲染。

#### 七、使用v-show替代v-if

对于频繁切换显示状态的元素，使用v-show可以保证虚拟dom树的稳定，避免频繁的新增和删除元素，特别是对于那些内部包含大量dom元素的节点，这一点极其重要。

关键字：频繁切换显示状态、内部包含大量dom元素。

#### 八、使用延迟装载（defer）

首页白屏时间主要受到两个因素的影响：
* 打包体积过大
  巨型包需要消耗大量的传输时间，导致JS传输完成前页面只有一个div，没有可显示的内容。
* 需要立即渲染的内容过多
  js传输完成后，浏览器开始执行js构造页面
  但可能一开始要渲染的组件太多，不仅js执行的时间很长，而且执行完成后浏览器要渲染的元素过多，从而导致页面白屏

打包体积过大需要自行优化打包体积，本节不予讨论

本节仅讨论渲染内容过多的问题

一个可行的办法就是延迟装载组件，让组件按照指定的先后循序依次一个一个渲染出来。
> 延迟装载是一个思路，本质上就是利用了requestAnimationFrame事件分批渲染内容，它的具体实现多种多样。

#### 九、使用keep-alive

#### 十、长列表优化