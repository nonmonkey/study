[TOC]

---

### 一、首先抛出 Vue2 的代码模式下存在的几个问题。

1. 随着功能的增长，复杂组件的代码变得越来越难以维护。 尤其发生你去新接手别人的代码时。 根本原因是 Vue 的现有 API 通过「选项」组织代码，但是在大部分情况下，通过逻辑考虑来组织代码更有意义。
2. 缺少一种比较「干净」的在多个组件之间提取和复用逻辑的机制。
3. 类型推断不够友好。

### 二、Hook 和 Mixin & HOC 对比

**Mixin & HOC 模式缺点：**
1. 渲染上下文中公开的属性的来源不清楚。 例如，当使用多个 mixin 读取组件的模板时，可能很难确定从哪个 mixin 注入了特定的属性。
2. 命名空间冲突。 Mixins 可能会在属性和方法名称上发生冲突，而 HOC 可能会在预期的 prop 名称上发生冲突。
3. 性能问题，HOC 和无渲染组件需要额外的有状态组件实例，这会降低性能。

**Hook**
1. 暴露给模板的属性具有明确的来源，因为它们是从 Hook 函数返回的值。
2. Hook 函数返回的值可以任意命名，因此不会发生名称空间冲突。
3. 没有创建仅用于逻辑重用的不必要的组件实例。

### 三、React Hook 和 Vue Hook对比

**其实 React Hook 的限制非常多，比如官方文档中就专门有一个章节介绍它的限制：**
1. 不要在循环，条件或嵌套函数中调用 Hook(因为 React Hooks 采用下标方式寻找状态，一旦位置不对或者 Hooks 放在了条件中，就无法正确找到对应位置的值)
2. 确保总是在你的 React 函数的最顶层调用他们。
3. 遵守这条规则，你就能确保 Hook 在每一次渲染中都按照同样的顺序被调用。这让 React 能够在多次的 useState 和 useEffect 调用之间保持 hook 状态的正确。

**而 Vue 带来的不同在于：**
1. 与 React Hooks 相同级别的逻辑组合功能，但有一些重要的区别。 与 React Hook 不同，setup 函数仅被调用一次，这在性能上比较占优。
2. 对调用顺序没什么要求，每次渲染中不会反复调用 Hook 函数，产生的的 GC 压力较小。
3. 不必考虑几乎总是需要 useCallback 的问题，以防止传递函数prop给子组件的引用变化，导致无必要的重新渲染。
4. React Hook 有臭名昭著的闭包陷阱问题（甚至成了一道热门面试题，omg），如果用户忘记传递正确的依赖项数组，useEffect 和 useMemo 可能会捕获过时的变量，这不受此问题的影响。 Vue 的自动依赖关系跟踪确保观察者和计算值始终正确无误。
5. 不得不提一句，React Hook 里的「依赖」是需要你去手动声明的，而且官方提供了一个 eslint 插件，这个插件虽然大部分时候挺有用的，但是有时候也特别烦人，需要你手动加一行丑陋的注释去关闭它。

### 四、React 和 Vue 的差别

vue的官网中说它是一款渐进式框架，采用自底向上增量开发的设计。这里我们需要明确一个概念，什么是渐进式框架。在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架。Vue从设计角度来讲，虽然能够涵盖所有这些内容，但是你并不需要一上手就把所有东西全用上，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。

react主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以手动实现，比如借助 onChange 和  setState 来实现一个双向的数据流。而vue是基于可变数据的，支持双向绑定，它提供了v-model这样的指令来实现文本框的数据流双向绑定。

Vue进行数据拦截/代理，他对侦测数据的变化更敏感，更精确，也间接对一些后续实现（比如hooks，function based API）提供了很大的遍利。

react提倡小组件，尽可能多的拆分为组件，而不是写一个大的模板；这里的拆分不一定是在抽出一个单文件，而是在render的内部写出很多小组件，徐飞说过组件拆分的目的是为了分治，而不是复用。这是jsx优于模板的一个地方，同时让你的render更为漂亮，可读性更高。

React 推崇函数式，他直接进行局部重新渲染（或者重新渲染），这样更粗暴，但是更简单。但是React并不知道什么时候去刷新，触发局部重新变化是由开发者手动调用setState完成。

React setState 引起局部重新刷新。为了达到更好的性能，React 暴漏给开发者 shouldComponentUpdate 这个生命周期 hook，来避免不需要的重新渲染（相比之下，Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少，而 React 对数据变化毫无感知，它就提供 React.createElement 调用已生成 virtual dom）。另外 React 为了弥补不必要的更新，会对 setState 的行为进行合并操作。因此 setState 有时候会是异步更新，但并不是总是“异步”

总体上，react像是在写程序，你用各种封装，抽象和模式来使得代码更为优雅和健壮，因此它适合做颗粒度很细的业务，它的可读性和美观也是在程序角度，而不是html，但是当业务没有那么复杂的适合，它会显得啰嗦。

vue其实是模板语言，社区好像并没有认真权衡模板和组件就一股脑的都组件化了，组件有状态，这就带来组件内状态共享的问题，于是又引入redux，vuex等。各个组件都有自己的状态，有些状态又需要共享，这样的代码在维护和阅读上都是不方便的，而且你很难确定一个状态是私有还是要共享的，随着业务的发展，很多状态明明是私有的又要被共享了。像dva等框架，它们几乎把所有状态都放redux，简洁明了，没有共享的问题，于是react又沦落成模板了。

