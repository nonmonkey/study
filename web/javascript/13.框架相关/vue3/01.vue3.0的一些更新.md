[TOC]
***

### 零、安装

npm install -g @vue/cli

### 一、构建工具
#### 1.webpack

#### 2.vite 构建工具(相比webpack打包过程更快)
npm init vite-app vue3.0-app-vite // 临时使用vite构建一个工程

##### 1）谈谈你对vite的理解，最好对比webpack说明


### 二、vue3.0
1.没有默认导出。不存在构造函数Vue(使用createApp方法创建一个vue应用)。

2.组件中this为一个代理。

3.composition api 
(vue2.0 option api 组件如果越来越复杂)

4.composition api 相比于 option api 的优势
1）为了更好的逻辑复用和代码组织
2）更好的类型推导
> 有了compositon api，配合reactivity api，可以在内部进行更加细粒的控制，使得组件中不同的功能高度聚合，提升了代码的可维护性。对于不同组件的相同功能，也能够更好的复用。
相比于option api，composition api中没有了指向奇怪的this，所有的api变得更加函数式，这有利于和类型推断系统比如TS深度结合。


### 三、vue3.0效率提升

#### 1.静态提升

* 没有绑定动态内容的节点
* 静态属性会被提升

#### 2.预字符串化

当编译器遇到大量连续的静态内容，会直接将其编译为一个普通的字符串节点

#### 3.缓存事件处理函数

#### 4.Block Tree

vue2在对比新旧树的时候，并不知道哪些节点是静态的，哪些是动态的，因此只能一层一层比较。这就浪费了大部分时间在对比静态节点上。

vue3只会对比动态节点。

#### 5.PatchFlag

vue2在对比每一个节点时，并不知道这个节点哪些相关信息会发生变化，因此只能将所有信息依次对比。

vue3只会对比动态属性（类型、属性、内容）


### 四、vue3.0为什么去掉了vue构造函数

vue2的全局构造函数带来了诸多问题：
1.调用构造函数的静态方法会对所有vue应用生效，不利于隔离不同应用。
2.vue2的构造函数集成了太多的功能，不利于tree shaking，vue3把这些功能使用普通函数导出，能够充分利用tree shaking优化打包体积。
3.vue2没有把组件实例和vue应用两个概念区分开，在vue2中，通过new Vue创建的对象，既是一个vue应用，同时又是一个特殊的vue组件。
vue3中，把这两个概念区分开，通过createApp创建的对象，是一个vue应用，它内部提供的方法是针对整个应用的，而不是一个特殊的组件

### 五、vue3.0谈谈你对数据响应式的理解

(vue2和vue3完成数据响应都是在beforeCreate之后和created之前)
vue3不再使用Object.defineProperty的方式定义完成数据响应式，而是使用Proxy。
除了Proxy本身效率比Object.defineProperty更高之外，由于不必递归便利所有属性，而是直接得到一个proxy，所以在vue3中，对
数据的访问是动态的，当访问某个属性时，再动态的获取和设置，这就极大的提升了在组件初始阶段的效率。
同时，由于Proxy可以监控到成员的新增和删除，因此，在vue3中新增成员、删除成员、索引访问等均可以触发重新渲染，而这些在vue2中是难以做到的。

### 六、vue3.0获取响应式数据

| API      | 传入             | 返回           | 备注                  |
|  ----  | ----  |  ----  | ----  |
| reactive | object          | 代理对象        | 深度代理对象中的所有成员 |
| readonly | object or proxy | 代理对象        | 只读(深度 )            |
| ref      | any             | { value: ... } | 对value的访问是响应式的，如果给value的值是一个对象，则会通过reactive函数进行代理，如果已经是代理，直接使用代理 |
| computed | funciton        | { value: ... } | 当读取value值时，会根据情况决定是否运行函数(有缓存) |

### 七、vue3.0监听

watchEffect 、watch 均是微队列

watchEffect 、watch选择：
1.不希望回调函数一开始就执行
2.数据改变时，需要参考旧值
3.需要监控一些回调函数中不会用到的数据。

### 1.watchEffect

```JS
watchEffect(() => {
  // 适用于响应性追踪
  console.log(copy.count)
})
```

### 2.watch

```JS
// 侦听一个getter
const state = reactive({ count: 0 })
watch(
  () => state.count,
  (count, prevCount) => {
    /* ... */
  }
)

// 直接侦听一个ref
const count = ref(0)
watch(count, (count, prevCount) => {
  /* ... */
})

// 监听多个数值
watch([fooRef, barRef], ([foo, bar], [prevFoo, prevBar]) => {
  /* ... */
})
```

### 八、vue3.0判断

| API      | 含义             |
|  ----  | ----  |
|  isProxy  | 判断是否由reactive或readonly创建  |
|  isReactive  | 判断是否由reactive创建  |
|  isReadonly  | 判断是否为readonly创建  |
|  isRef  |  判断是否由ref创建  |

### 九、转换

| API      | 含义             |
| ----  | ----  |
| unref | 等同于isRef(val) ? val.value : val  |
| toRefs | 把一个响应式对象的所有属性转换为ref格式，然后包装到一个plain-object中返回 |
| toRef | 可以用来为源响应式对象上的 property 性创建一个 ref。然后可以将 ref 传递出去，从而保持对其源 property 的响应式连接。  |

